name: Update Zenodo Metadata

on:
  release:
    types: [published]

permissions:
  contents: read

jobs:
  update-zenodo:
    name: Update Zenodo Metadata
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Extract release information
        id: release_info
        run: |
          echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          echo "release_date=$(date -u +%Y-%m-%d)" >> $GITHUB_OUTPUT
          
      - name: Update CITATION.cff with new version
        run: |
          VERSION="${{ steps.release_info.outputs.version }}"
          DATE="${{ steps.release_info.outputs.release_date }}"
          
          # Update version in CITATION.cff
          sed -i "s/^version: .*/version: ${VERSION}/" CITATION.cff
          sed -i "s/^date-released: .*/date-released: ${DATE}/" CITATION.cff
          
      - name: Prepare Zenodo metadata
        id: zenodo_metadata
        run: |
          VERSION="${{ steps.release_info.outputs.version }}"
          RELEASE_NAME="${{ github.event.release.name }}"
          RELEASE_BODY="${{ github.event.release.body }}"
          
          # Create Zenodo-compatible metadata JSON
          cat > zenodo_metadata.json <<EOF
          {
            "metadata": {
              "title": "Universal Prompt Security Standard (UPSS)",
              "upload_type": "software",
              "publication_date": "${{ steps.release_info.outputs.release_date }}",
              "version": "${VERSION}",
              "description": "A comprehensive framework for externalizing, securing, and managing LLM prompts and generative AI systems across any organization or project. ${RELEASE_BODY}",
              "creators": [
                {
                  "name": "Veroy, Alvin T.",
                  "affiliation": "Independent Researcher"
                }
              ],
              "keywords": [
                "AI security",
                "prompt injection",
                "large language models",
                "security standards",
                "prompt management",
                "LLM security",
                "generative AI",
                "prompt engineering",
                "cybersecurity",
                "software security"
              ],
              "license": "MIT",
              "access_right": "open",
              "related_identifiers": [
                {
                  "identifier": "https://github.com/alvinveroy/prompt-security-standard",
                  "relation": "isSupplementTo",
                  "scheme": "url"
                }
              ],
              "references": [
                "OWASP Top 10 for Large Language Model Applications",
                "NIST AI Risk Management Framework",
                "ISO/IEC 27001:2022 Information Security Management"
              ]
            }
          }
          EOF
          
          cat zenodo_metadata.json
          
      - name: Update Zenodo deposition
        env:
          ZENODO_ACCESS_TOKEN: ${{ secrets.ZENODO_ACCESS_TOKEN }}
          ZENODO_DEPOSITION_ID: ${{ secrets.ZENODO_DEPOSITION_ID }}
        run: |
          if [ -z "$ZENODO_ACCESS_TOKEN" ]; then
            echo "Warning: ZENODO_ACCESS_TOKEN not set. Skipping Zenodo update."
            echo "Please add ZENODO_ACCESS_TOKEN to repository secrets to enable automatic Zenodo updates."
            exit 0
          fi
          
          if [ -z "$ZENODO_DEPOSITION_ID" ]; then
            echo "Warning: ZENODO_DEPOSITION_ID not set. Skipping Zenodo update."
            echo "Please add ZENODO_DEPOSITION_ID to repository secrets to enable automatic Zenodo updates."
            exit 0
          fi
          
          # Create a new version of the Zenodo deposition
          echo "Creating new version on Zenodo..."
          NEW_VERSION_RESPONSE=$(curl -sS -X POST \
            "https://zenodo.org/api/deposit/depositions/${ZENODO_DEPOSITION_ID}/actions/newversion" \
            -H "Authorization: Bearer ${ZENODO_ACCESS_TOKEN}")
          
          echo "New version response: ${NEW_VERSION_RESPONSE}"
          
          # Extract the new draft deposition ID
          NEW_DRAFT_URL=$(echo "$NEW_VERSION_RESPONSE" | jq -r '.links.latest_draft')
          NEW_DRAFT_ID=$(echo "$NEW_DRAFT_URL" | grep -oP '/depositions/\K[0-9]+')
          
          if [ -z "$NEW_DRAFT_ID" ]; then
            echo "Error: Failed to create new version. Response:"
            echo "$NEW_VERSION_RESPONSE"
            exit 1
          fi
          
          echo "New draft deposition ID: ${NEW_DRAFT_ID}"
          
          # List and delete existing files from the new draft
          echo "Checking for existing files in the new draft..."
          FILES_RESPONSE=$(curl -sS -X GET \
            "https://zenodo.org/api/deposit/depositions/${NEW_DRAFT_ID}/files" \
            -H "Authorization: Bearer ${ZENODO_ACCESS_TOKEN}")
          
          echo "Files response: ${FILES_RESPONSE}"
          
          # Extract file IDs and count
          FILE_IDS=$(echo "$FILES_RESPONSE" | jq -r '.[].id')
          FILE_COUNT=$(echo "$FILE_IDS" | wc -l | tr -d ' ')
          
          echo "Found ${FILE_COUNT} files in the draft"
          
          if [ "$FILE_COUNT" -gt 0 ] && [ -n "$FILE_IDS" ]; then
            echo "Deleting existing files..."
            
            # Loop through each file and delete it
            for FILE_ID in $FILE_IDS; do
              if [ -n "$FILE_ID" ] && [ "$FILE_ID" != "null" ]; then
                echo "Deleting file ID: ${FILE_ID}"
                
                DELETE_RESPONSE=$(curl -sS -X DELETE \
                  "https://zenodo.org/api/deposit/depositions/${NEW_DRAFT_ID}/files/${FILE_ID}" \
                  -H "Authorization: Bearer ${ZENODO_ACCESS_TOKEN}")
                
                DELETE_STATUS=$(echo "$DELETE_RESPONSE" | jq -r '.status // empty')
                if [ "$DELETE_STATUS" = "400" ] || [ "$DELETE_STATUS" = "500" ]; then
                  echo "❌ Error: Failed to delete file ${FILE_ID}"
                  echo "Status: $DELETE_STATUS"
                  echo "Response: $DELETE_RESPONSE"
                  exit 1
                fi
                
                echo "✅ Successfully deleted file ${FILE_ID}"
              fi
            done
            
            echo "✅ All existing files have been deleted"
          else
            echo "No existing files found, proceeding with metadata update"
          fi
          
          # Update the metadata for the new draft
          echo "Updating metadata for new version..."
          UPDATE_RESPONSE=$(curl -sS -X PUT \
            "https://zenodo.org/api/deposit/depositions/${NEW_DRAFT_ID}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${ZENODO_ACCESS_TOKEN}" \
            -d @zenodo_metadata.json)
          
          echo "Update response: ${UPDATE_RESPONSE}"
          
          # Check for errors in update response
          UPDATE_STATUS=$(echo "$UPDATE_RESPONSE" | jq -r '.status // empty')
          if [ "$UPDATE_STATUS" = "400" ] || [ "$UPDATE_STATUS" = "500" ]; then
            echo "❌ Error: Failed to update metadata"
            echo "Status: $UPDATE_STATUS"
            echo "Message: $(echo "$UPDATE_RESPONSE" | jq -r '.message // empty')"
            echo "Errors: $(echo "$UPDATE_RESPONSE" | jq -r '.errors // empty')"
            exit 1
          fi
          
          # Publish the new version
          echo "Publishing new version..."
          PUBLISH_RESPONSE=$(curl -sS -X POST \
            "https://zenodo.org/api/deposit/depositions/${NEW_DRAFT_ID}/actions/publish" \
            -H "Authorization: Bearer ${ZENODO_ACCESS_TOKEN}")
          
          echo "Publish response: ${PUBLISH_RESPONSE}"
          
          # Check for errors in publish response
          PUBLISH_STATUS=$(echo "$PUBLISH_RESPONSE" | jq -r '.status // empty')
          if [ "$PUBLISH_STATUS" = "400" ] || [ "$PUBLISH_STATUS" = "500" ]; then
            echo "❌ Error: Failed to publish new version"
            echo "Status: $PUBLISH_STATUS"
            echo "Response: $PUBLISH_RESPONSE"
            exit 1
          fi
          
          # Extract and display the new DOI
          NEW_DOI=$(echo "$PUBLISH_RESPONSE" | jq -r '.doi // empty')
          if [ -z "$NEW_DOI" ] || [ "$NEW_DOI" = "null" ]; then
            echo "❌ Error: Failed to extract DOI from publish response"
            echo "Response: $PUBLISH_RESPONSE"
            exit 1
          fi
          
          echo "✅ Successfully published new version to Zenodo!"
          echo "New DOI: ${NEW_DOI}"
          echo "Zenodo URL: https://doi.org/${NEW_DOI}"
          
      - name: Summary
        run: |
          echo "## Zenodo Metadata Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.release_info.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Date**: ${{ steps.release_info.outputs.release_date }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ✅ Workflow completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "If Zenodo secrets are configured, check the Zenodo record for the updated metadata." >> $GITHUB_STEP_SUMMARY
